* CPU  
&emsp; 物理CPU  
&emsp; 物理核心  
&emsp; 逻辑核心  
&emsp; 逻辑核心  
&emsp; &emsp; 超线程技术  
&emsp; &emsp; 物理核心*2  
&emsp; &emsp; 每个核都有独立cache  
&emsp; 多核Cache一致性由硬件保证，对软件来说是透明的（一致性协议）  
  
* SMP  
&emsp; 对称多处理（同构多核）  
&emsp; 多个核心相对独立的运行不同的任务，每个核心可能运行不同的操作系统  
&emsp; 每个核心有自己的内存空间，同时会有共享的内存空间  
&emsp; 两者之间还有一定的通信机制  
&emsp; 主要核心+次要核心  
&emsp; 从硬件上来说，这种多处理模式可能是同构的，也可能是异构的，但大多情况是异构多处理器。  
* AMP  
&emsp; 非对称多处理（异构多核）  
&emsp; 一个OS同等的管理各个核心  
  
* 中断  
&emsp; 计算机处于执行期间，系统发生了非预期的紧急事件，CPU暂时中断当前正在执行的程序而转去执行相应的中断处理程序，处理完毕后返回原来被中断处继续执行  
&emsp; 中断向量表->中断描述符->中断处理程序  
&emsp; 同步中断（异常）  
&emsp; &emsp; 由CPU产生  
&emsp; &emsp; 产生信号/缺页异常/系统调用  
&emsp; 异步中断（中断）  
&emsp; &emsp; 新型的线程化中断  
&emsp; &emsp; 优先级：  
&emsp; &emsp; &emsp; 响应优先级  
&emsp; &emsp; &emsp; 嵌套优先级  
&emsp; 类型：  
&emsp; &emsp; 可屏蔽中断INTR  
&emsp; &emsp; &emsp; 单独控制：每个中断有屏蔽位  
&emsp; &emsp; &emsp; 总控制：  
&emsp; &emsp; &emsp; &emsp; CPU标志寄存器中的中断允许标志位IF  
&emsp; &emsp; &emsp; &emsp; IF位由用户控制，STI将IF位置1(开中断)，CLI将IF位清0(关中断)  
&emsp; &emsp; 不可屏蔽中断NMI  
&emsp; &emsp; &emsp; 电源断电、内存校验错误  
&emsp; 开关：  
&emsp; &emsp; 简单禁止和激活当前处理器上的所有中断  
&emsp; &emsp; &emsp; local_irq_disable()/local_irq_enable()/local_irq_save(flags)/local_irq_restore(flags)  
&emsp; &emsp; 在全局范围内屏蔽所有CPU的某一个中断  
&emsp; &emsp; &emsp; disable_irq/enable_irq：关闭后，等待中断执行完毕  
&emsp; &emsp; &emsp; disable_irq_nosync：关中断，并不等待中断执行完毕  
&emsp; &emsp; 多个中断处理：  
&emsp; &emsp; &emsp; 关闭中断标志位，挂起其他所有中断  
&emsp; &emsp; &emsp; &emsp; 或  
&emsp; &emsp; &emsp; 中断嵌套，高优先级打断低优先级（linux不支持中断嵌套，x86平台本身也不支持）  
  
* 软中断  
&emsp; 可以在所有处理器上同时执行，即使两个类型相同也可以  
&emsp; 一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是硬中断  
&emsp; 哪个cpu上的硬中断带来的软中断就由哪个cpu处理  
&emsp; 触发：raise_softirq()  
&emsp; 执行：do_softirq()  
&emsp; 检查：  
&emsp; &emsp; 从硬件中断返回  
&emsp; &emsp; ksoftirqd内核线程（每个处理器都有）  
&emsp; &emsp; &emsp; local_irq_disable + local_irq_enable  
&emsp; &emsp; 显式检查和执行待处理的软中断的代码，如网络子系统中  
&emsp; &emsp; local_bh_enable  
  
* 上半部：  
&emsp; 中断处理程序  
* 下半部：  
&emsp; 软中断  
&emsp; &emsp; 一个软中断可以不同CPU运行，需要考虑重入  
&emsp; taskelet  
&emsp; &emsp; 本质上也是软中断，只不过同一个tasklet不能再多个处理器上同时运行，不需要考虑重入  
&emsp; 工作队列  
&emsp; &emsp; 内核线程  
  
* 周期  
&emsp; 时钟周期  
&emsp; 指令周期  
&emsp; &emsp; 计算机从取指到指令执行完毕的时间  
&emsp; &emsp; Fetch（取指）  
&emsp; &emsp; Decode（译码）  
&emsp; &emsp; Execute（执行指令）  
&emsp; CPU周期（机器周期）  
&emsp; &emsp; 一条指令的执行过程划分为若干个阶段：如取指令、存储器读、存储器写等  
&emsp; &emsp; 每一阶段称为一个基本操作  
&emsp; &emsp; 完成一个基本操作所需要的时间称为机器周期  
&emsp; &emsp; 通常用内存中读取一个指令字的最短时间来规定CPU周期  
&emsp; 关系  
&emsp; &emsp; 1个指令周期 >= 2个CPU周期  
&emsp; &emsp; 1个CPU周期  == n个时钟周期  
  
* 硬中断处理  
&emsp; 硬件：  
&emsp; &emsp; CPU在执行当前指令的最后一个时钟周期去查询INTR引脚  
&emsp; &emsp; 由硬件保存程序计数器(PC，PC == CS + IP)  
&emsp; &emsp; 关中断（软硬件操作都行）  
&emsp; &emsp; 中断向量->中断向量表->中断描述符->中断处理程序->序计数器(PC)  
&emsp; 软件：  
&emsp; &emsp; 保护上下文，寄存器入栈  
&emsp; &emsp; 关中断（硬件如果没有关，就由软件关）/开中断（硬件如果关中断，此处由软件打开，可以实现中断嵌套）  
&emsp; &emsp; 中断服务  
&emsp; &emsp; 开中断  
&emsp; &emsp; 下半部  
&emsp; &emsp; 恢复上下文，寄存器出栈  
&emsp; 中断返回原断点处，继续执行  
  
* linux中断机制  
http://cloud.tencent.com/developer/article/1708958  
&emsp; 硬中断原则：  
&emsp; &emsp; 不能嵌套  
&emsp; &emsp; 越快越好  
  
* 多核CPU处理中断  
&emsp; 由全局中断控制器接收请求并决定交给哪一个核心处理  
&emsp; 也可让所有的中断都被一个固定的核心处理  
  
* preempt_count  
https://zhuanlan.zhihu.com/p/88883239  
&emsp; thread_info->preempt_count或每CPU变量  
&emsp; 0：可抢占，非0：不可抢占  
&emsp; 32位，分为四部分  
&emsp; &emsp; 抢占计数  
&emsp; &emsp; &emsp; 第0到7个bit  
&emsp; &emsp; &emsp; preempt_disable()/preempt_enable()  
&emsp; &emsp; 软中断计数  
&emsp; &emsp; &emsp; 第8到15个bit  
&emsp; &emsp; &emsp; 软中断嵌套次数  
&emsp; &emsp; &emsp; softirq在单个CPU上是不会嵌套执行的，因此和hardirq count一样，实际只需要一个bit 8就可以了  
&emsp; &emsp; &emsp; local_bh_disable()/local_bh_enable记录在高7位  
&emsp; &emsp; &emsp; &emsp; 在“进程上下文”中，为了防止进程被softirq所抢占，关闭/禁止softirq的次数  
&emsp; &emsp; 硬件中断计数  
&emsp; &emsp; &emsp; 16到19个bit  
&emsp; &emsp; &emsp; 硬中断嵌套次数  
&emsp; &emsp; &emsp; 现在不支持硬中断嵌套，实际只使用1位  
&emsp; &emsp; &emsp; irq_enter()/irq_exit()  
&emsp; &emsp; NMI计数  
  
* 进程上下文  
* 中断上下文  
&emsp; #define in_interrupt() irq_count()  
&emsp; 严格来说，并不是判断中断，而是判断是否会嵌套软硬中断  
* 原子上下文  
&emsp; #define in_atomic()&emsp; (preempt_count() != 0)  
&emsp; 中断/软中断/持有自旋锁  
* 软中断上下  
&emsp; 一是在下半部执行的软中断处理包括tasklet，irq_exit()->invoke_softirq()  
&emsp; 二是内核线程中执行的软中断，比如中断线程/ksoftirqd内核线程  
&emsp; 三是进程上下文中调用local_bh_enable()执行的软中断，local_bh_enable()->do_softirq()  
&emsp; 一属于传统意义的中断上下文，二、三属于进程上下文  
  
* 抢占  
&emsp; 如果不主动释放CPU，在时间片用完或者高优先级任务就绪的情况下，会被强行剥夺掉CPU的使用权  
&emsp; 软硬中断可以打断进程，反之不行；中断优先级更高，中断上下文中永远不允许进程切换；local_bh_enable/local_bh_disable只是操作抢占计数  
&emsp; preempt_count不是0，内核抢占被禁用  
&emsp; 用户抢占  
&emsp; &emsp; 内核态（系统调用/中断）返回用户态  
&emsp; &emsp; 进程thread_info中设置了need_resched标识  
&emsp; &emsp; 条件：  
&emsp; &emsp; &emsp; 当前进程时间片消耗完  
&emsp; &emsp; &emsp; 高优先级进程就绪  
&emsp; &emsp; &emsp; 降低当前进程优先级  
&emsp; 内核抢占  
&emsp; &emsp; 在内核态  
&emsp; &emsp; 编译内核开启“内核抢占”  
&emsp; &emsp; preempt_disable关闭抢占后，内核不可抢占；锁都会关抢占  
&emsp; &emsp; 发生内核抢占的时机：  
&emsp; &emsp; &emsp; 中断处理函数返回到内核态，会调度一个任务执行，相当于“隐式schedule”  
&emsp; &emsp; &emsp; 内核可以再次抢占，即preempt_count从正整数变为0  
&emsp; &emsp; &emsp; &emsp; 各种解锁  
&emsp; &emsp; &emsp; &emsp; local_bh_enable  
&emsp; &emsp; &emsp; 任务显式或通过阻塞操作间接schedule  
&emsp; &emsp; 需要禁止内核抢占的点：  
&emsp; &emsp; &emsp; 软硬中断：优先级更高，已默认关闭抢占  
&emsp; &emsp; &emsp; 锁：自旋锁/读写锁都自动关闭抢占  
&emsp; &emsp; &emsp; schedule：正在调度时，也要关闭抢占  
&emsp; &emsp; &emsp; 访问每CPU变量：防止进程调度，访问其他CPU，需要关闭抢占（软硬中断没有这个问题）  
  
* 自旋锁中休眠带来的问题  
&emsp; 中断上下文：  
&emsp; &emsp; 不管用什么api，都绝对不能休眠  
&emsp; 进程上下文：  
&emsp; &emsp; spinlock_irq关中断  
&emsp; &emsp; &emsp; 时钟中断无法执行，CPU可能无法调度，卡死  
&emsp; &emsp; spinlock开中断  
&emsp; &emsp; &emsp; 首先preempt_disable()关抢占，只是别人不能抢占，自己还是可以主动让出CPU  
&emsp; &emsp; &emsp; 休眠会显式通过schedule让出CPU  
&emsp; &emsp; &emsp; 如果切换到其他进程上下文，会一直尝试获取锁，可能等待很长时间  
&emsp; &emsp; &emsp; 如果切换到这个进程上下文，就会死锁  
  
* 中断上下文休眠带来的问题  
&emsp; 从上下文切换和任务调度角度：  
&emsp; &emsp; 上下文切换和任务调度都是以进程为单位  
&emsp; &emsp; 进程上下文对应有进程描述符  
&emsp; &emsp; 中断上下文没有对应的中断描述符  
&emsp; &emsp; 中断上下文内不能休眠，不能切换和调度  
&emsp; 非要实现中断上下文切换和任务调度也是可以的：  
&emsp; &emsp; 加入中断描述符，切换上下文和任务调度时也支持中断  
&emsp; &emsp; 频繁的中断休眠，容易使中断栈溢出，且产生很多性能甚至功能问题，如IPI进程间中断休眠，其他CPU就死循环等待；时钟中断休眠，进程调度就有问题  
&emsp; 从中断意义角度：  
&emsp; &emsp; 中断优先级很高，必须立刻处理  
&emsp; &emsp; 中断不应该依赖进程或者中断  
&emsp; 从linux设计角度：  
&emsp; &emsp; linux就是按照“中断上下文不允许休眠”设计的  
&emsp; &emsp; 在中断上下文，内核不可抢占，休眠必然挂起  
&emsp; &emsp; switchto会失败，中断不是可切换的任务  
&emsp; &emsp; schedule函数在进来的时候判断是否in_interrupt()  
  
-----------------------------------------TODO-----------------------------------------  
保护临界区  
&emsp; 硬中断>软中断=tasklet>进程上下文  
&emsp; 进程上下文才能用信号量同步  
&emsp; 同一个CPU关抢占  
&emsp; 不同CPU之间用spinlock同步  
&emsp; 低优先级想禁止高优先级，可以关闭软中断或者硬中断  
-----------------------------------------TODO-----------------------------------------  
