中断
    计算机处于执行期间，系统发生了非预期的紧急事件，CPU暂时中断当前正在执行的程序而转去执行相应的中断处理程序，处理完毕后返回原来被中断处继续执行
    中断向量表->中断描述符->中断处理程序
    同步中断（异常）
        由CPU产生
        产生信号/缺页异常/系统调用
    异步中断（中断）
        新型的线程化中断
        优先级：
            响应优先级
            嵌套优先级
        类型：
            可屏蔽中断INTR
                单独控制：
                    每个中断有屏蔽位
                总控制：
                    CPU标志寄存器中的中断允许标志位IF
                    IF位由用户控制，STI将IF位置1(开中断)，CLI将IF位清0(关中断)
            不可屏蔽中断NMI
                电源断电、内存校验错误
        开关：
            简单禁止和激活当前处理器上的所有中断
                local_irq_disable()/local_irq_enable()/local_irq_save(flags)/local_irq_restore(flags)                
            在全局范围内屏蔽所有CPU的某一个中断
                disable_irq/enable_irq：关闭后，等待中断执行完毕
                disable_irq_nosync：关中断，并不等待中断执行完毕
        多个中断处理：
            关闭中断标志位，挂起其他所有中断
                或
            中断嵌套，高优先级打断低优先级（linux不支持中断嵌套，x86平台本身就不支持）

软中断
    可以在所有处理器上同时执行，即使两个类型相同也可以
    一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是硬中断
    哪个cpu上的硬中断带来的软中断就由哪个cpu处理
    触发：raise_softirq()
    执行：do_softirq()
    检查：
        从硬件中断返回
        ksoftirqd内核线程（每个处理器都有）
            local_irq_disable + local_irq_enable
        显式检查和执行待处理的软中断的代码，如网络子系统中
        local_bh_enable

上半部：
    中断处理程序
下半部：
    软中断
        一个软中断可以不同CPU运行，需要考虑重入
    taskelet
        本质上也是软中断，只不过同一个tasklet不能再多个处理器上同时运行，不需要考虑重入
    工作队列
        内核线程
        

-----------------------------------------TODO-----------------------------------------
中断处理
    disable_irq_nosync屏蔽所有CPU的该中断
    设置硬件寄存器的中断标志位，禁止中断
    保存上下文
    中断处理程序
    设置硬件寄存器的中断标志位，使能中断
    使能CPU的该中断
-----------------------------------------TODO-----------------------------------------


多核CPU处理中断
    由全局中断控制器接收请求并决定交给哪一个核心处理
    也可让所有的中断都被一个固定的核心处理

preempt_count
    https://zhuanlan.zhihu.com/p/88883239
    thread_info->preempt_count或每CPU变量
    0：可抢占，非0：不可抢占
    32位，分为四部分
        抢占计数
            第0到7个bit
            preempt_disable()/preempt_enable()
        软中断计数
            第8到15个bit
            软中断嵌套次数
            softirq在单个CPU上是不会嵌套执行的，因此和hardirq count一样，实际只需要一个bit 8就可以了
            local_bh_disable()/local_bh_enable记录在高7位
                在“进程上下文”中，为了防止进程被softirq所抢占，关闭/禁止softirq的次数
        硬件中断计数
            16到19个bit
            硬中断嵌套次数
            现在不支持硬中断嵌套，实际只使用1位
            irq_enter()/irq_exit()
        NMI计数

进程上下文
中断上下文
    #define in_interrupt() irq_count()
原子上下文
    #define in_atomic()	(preempt_count() != 0)

软中断可能处于中断上下文/进程上下文（ksoftirqd）

抢占
    定义：
        如果主动不释放 CPU，在时间片用完或者高优先级任务就绪的情况下，会被强行剥夺掉CPU的使用权
    软硬中断可以打断进程，反之不行；中断优先级更高，中断上下文中永远不允许进程切换；local_bh_enable/local_bh_disable只是操作抢占计数
    preempt_count不是0，内核抢占被禁用
    用户抢占
        内核态（系统调用/中断）返回用户态
        进程thread_info中设置了need_resched标识
        条件：
            当前进程时间片消耗完
            高优先级进程就绪
            降低当前进程优先级
    内核抢占
        在内核态
        编译内核开启“内核抢占”
        preempt_disable关闭抢占后，内核不可抢占；锁都会关抢占
        发生内核抢占的时机：
            中断处理函数返回到内核态，会调度一个任务执行，相当于“隐式schedule”
            内核可以再次抢占，即preempt_count从正整数变为0
                各种解锁
                local_bh_enable
            任务显式或通过阻塞操作间接schedule
        需要禁止内核抢占的点：
            软硬中断：优先级更高，已默认关闭抢占
            锁：自旋锁/读写锁都自动关闭抢占
            schedule：正在调度时，也要关闭抢占
            访问每CPU变量：防止进程调度，访问其他CPU，需要关闭抢占（软硬中断没有这个问题）

自旋锁中休眠带来的问题
    中断上下文：
        不管用什么api，都绝对不能休眠
    进程上下文：
        spinlock_irq关中断
            时钟中断无法执行，CPU可能无法调度，卡死
        spinlock开中断
            首先preempt_disable()关抢占，只是别人不能抢占，自己还是可以主动让出CPU
            休眠会显式通过schedule让出CPU
            如果切换到其他进程上下文，会一直尝试获取锁，可能等待很长时间
            如果切换到这个进程上下文，就会死锁

中断上下文休眠带来的问题
    从上下文切换和任务调度角度：
        上下文切换和任务调度都是以进程为单位
        进程上下文对应有进程描述符
        中断上下文没有对应的中断描述符
        中断上下文内不能休眠，不能切换和调度
    非要实现中断上下文切换和任务调度也是可以的：
        加入中断描述符，切换上下文和任务调度时也支持中断
        频繁的中断休眠，容易使中断栈溢出，且产生很多性能甚至功能问题，如IPI进程间中断休眠，其他CPU就死循环等待；时钟中断休眠，进程调度就有问题
    从中断意义角度：
        中断优先级很高，必须立刻处理
        中断不应该依赖进程或者中断
    从linux设计角度：
        linux就是按照“中断上下文不允许休眠”设计的
        在中断上下文，内核不可抢占，休眠必然挂起
        switchto会失败，中断不是可切换的任务
        schedule函数在进来的时候判断是否in_interrupt()

-----------------------------------------TODO-----------------------------------------
保护临界区
    硬中断>软中断=tasklet>进程上下文
    进程上下文才能用信号量同步
    同一个CPU关抢占
    不同CPU之间用spinlock同步
    低优先级想禁止高优先级，可以关闭软中断或者硬中断
-----------------------------------------TODO-----------------------------------------
