* 状态机
	* 概念
		* 有限自动机FA
			* 确定性有限自动机DFA
			* 非确定性有限自动机NFA
		* 有限状态集
		* 输入字符集
		* 转移函数
		* 起始状态
		* 接受状态
		* 从**起始状态**，接受一系列输入字符，可以转移到**接受状态**，即认为这一系列字符可以**被自动机接受**
		* 如果两台自动机能够**接受**的输入字符串完全相同，则这两台自动机**等价**
		* 对于每一个NFA，都存在与之等价的DFA
	* 区别
		* NFA中一个状态可以不经过任何符号就可以实现状态转换(即存在ε-转移)
		* 对于一个特定的符号输入，DFA只会跳转到一个状态，而NFA则可能跳转到多个状态
	* NFA
		* 需要记录中间状态，可回溯
		* 广度优先搜索BFS 或 深度优先搜索DFS
		* 从正则表达式翻译过来的状态机是ε-NFA
	* DFA
		* 速度快，内存占用大
		* 对DFA进行简化，求出最简DFA
		* 简化的本质是合并性质相同的状态，以减少整个图的大小

------------
* AC

	https://blog.csdn.net/Changxing_J/article/details/104698941
	* 在**前缀树**的基础上，为前缀树的每个节点建立一棵**后缀树**
	* 有向有环图
	* 状态 -> 节点
	* goto表
		* 模式串创建的前缀树
		* 可接受任意字符
	* output表
		* 记录**状态**是否对应**某个或某些模式串**
		* 可看作是状态的一个成员变量
	* fail表
		* 保存状态间一对一的关系，存储状态转移失败后应当回退的**最佳状态**（能记住的已匹配上的字符串存在于goto表中的最长后缀的那个状态）
		* **初始状态**和**与初始状态直接相连的所有状态**，其fail指针都指向初始状态
		* 从初始状态开始进行广度优先遍历（BFS），若当前状态S接受字符c直达的状态为T，则沿着S的fail指针回溯，直到找到第一个前驱状态F，使得F.goto(c)!=null。将T的fail指针设为F.goto(c)。简单来说，就是寻找状态S的存在于goto表中的最长后缀的状态F
		* 将F的output添加到T的output中（状态5的he）
		
		![](https://img-blog.csdnimg.cn/20200306163844494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYW5neGluZ19K,size_16,color_FFFFFF,t_70)

------------
* WM

------------
* KMP

------------
* BM
